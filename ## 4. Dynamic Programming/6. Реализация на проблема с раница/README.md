# Реализация на проблема с раница

В тази лекция ще разгледаме конкретната реализация на проблема с раницата с помощта на динамично програмиране. Реализацията се състои от три основни компонента: клас KnapsackProblem, заглавен файл и основна функция за изпълнение на алгоритъма.

## Преглед

Проблемът с раницата е класически оптимизационен проблем, при който целта е да се определи максималната стойност, която може да се побере в раница с даден капацитет, като се вземат предвид теглата и стойностите на наличните артикули.

### Дефиниране на проблема

- **Елементи:** Имаме три артикула, определени от техните тегла и стойности:
 - Артикул 1: Тегло = 4 кг, Стойност = $10
 - Артикул 2: Тегло = 2 кг, Стойност = $4
 - Артикул 3: Тегло = 3 кг, Стойност = $7
- **Капацитет на раницата:** Максималното тегло на раницата е 5 кг.

## Подробности за внедряването

### Заглавен файл

В заглавния файл ние дефинираме следните ключови променливи:
- **Брой артикули:** Представлява общия брой налични артикули.
- **Капацитет на раницата:** Максималното тегло, което може да носи раницата.
- **Таблица на раницата:** Двуизмерен масив (вектор), който съхранява максималната постижима стойност за всяка комбинация от елементи и капацитет на тегло.

#### Обяснение на масата за раница

Таблицата на раница \( S[i][w] \) се използва за съхраняване на максималната цена (стойност) на артикули, които могат да се поберат в раница с размер \( w \), като се избира от първите \( i \) артикули . Размерите на масата са:
- Редове: Брой елементи + 1
- Колони: Капацитет + 1

### Стъпки на алгоритъма

1. **Инициализация:** Създайте таблицата с раницата с размери `(брой елементи + 1) x (капацитет + 1)`.
2. **Подход на динамично програмиране:**
 - Итерация през елементите и теглата.
 - За всеки артикул решете дали да го включите или изключите въз основа на ограничението за тегло.
 - Ако артикулът е включен, изчислете новата максимална стойност.
 - Първият ред и първата колона се инициализират на нули, представляващи никакви елементи или капацитет.

3. **Рекурентна връзка:**
 - Ако теглото на текущия артикул \( w[i] \) е по-малко или равно на текущия капацитет \( W \):
 - `S[i][W] = max(S[i-1][W], стойност[i-1] + S[i-1][W-w[i-1]])'
 - Ако артикулът не е включен:
 - `S[i][W] = S[i-1][W]`

### Резултати

За да определите кои елементи са включени в оптималното решение:
- Започнете от последната клетка на таблицата с раница.
- Ако стойността се различава от клетката по-горе, елементът е включен.
- Намалете съответно капацитета и продължете да проверявате предишните елементи.

### Примерен код

Ето опростена реализация на алгоритъма в C++:

```cpp
#include <iostream>
#include <вектор>

използване на пространство от имена std;

class KnapsackProblem {
публичен:
 int раница(int капацитет, вектор<int>& тегла, вектор<int>& стойности, int n) {
 вектор<вектор<int>> dp(n + 1, вектор<int>(капацитет + 1, 0));

 за (int i = 1; i <= n; i++) {
 за (int w = 0; w <= капацитет; w++) {
 if (тегла [i - 1] <= w) {
 dp[i][w] = max(dp[i - 1][w], стойности[i - 1] + dp[i - 1][w - тегла[i - 1]]);
 } иначе {
 dp[i][w] = dp[i - 1][w];
 }
 }
 }
 връщане dp[n][капацитет];
 }

 void findItems(int капацитет, вектор<int>& тегла, вектор<int>& стойности, int n, вектор<vector<int>>& dp) {
 cout << "Елементи, включени в раницата:\n";
 int w = капацитет;
 за (int i = n; i > 0 && w > 0; i--) {
 if (dp[i][w] != dp[i - 1][w]) {
 cout << "Елемент " << i << " (Тегло: " << тегла[i - 1] << ", Стойност: " << стойности [i - 1] << ")\n";
 w -= тегла [i - 1];
 }
 }
 }
};

int main() {
 Проблем с раницата kp;
 вектор<int> тегла = {4, 2, 3};
 вектор<int> стойности = {10, 4, 7};
 int капацитет = 5;
 int n = weights.size();

 int maxValue = kp.knapsack(капацитет, тегла, стойности, n);
 cout << "Максимална стойност в раницата: $" << maxValue << endl;

 връщане 0;
}
