# Симулация на памет на стека и памет на купчина

В този документ ще изследваме какво се случва с паметта на стека и паметта на стека, когато имаме работа с функции и обекти в програмирането. Разбирането на тези концепции е от решаващо значение за ефективното управление на паметта в езици като C++.

## Ключови понятия

1. **Стекова памет**
 - **Определение**: Паметта на стека е специален регион в RAM, който съхранява локални променливи и информация за извикване на функция.
 - **Извикване на функция**: Когато се извика функция, в паметта на стека се създава нова стекова рамка.
 - **Локални променливи**: Тези променливи се съхраняват в рамката на стека, свързана с тази функция.

2. **Групова памет**
 - **Дефиниция**: Heap паметта е по-голям регион в RAM, използван за динамично разпределение на паметта (напр. при създаване на обекти).
 - **Съхранение на обекти**: Обектите се съхраняват в стекова памет, докато препратките към тези обекти се съхраняват в стекова памет.

## Преглед на симулацията

### Извиквания на функции

1. **Извикване на функция едно**
 - Когато извикаме `functionOne`, в паметта на стека се създава нова стекова рамка.
 - Локалните променливи (напр. `int a = 10;`) се съхраняват в тази стекова рамка.

2. **Извикване на функция две от функция едно**
 - `functionOne` извиква `functionTwo`, създавайки друга стекова рамка върху предишната.
 - Локалните променливи и параметри за `functionTwo` се съхраняват в собствена стекова рамка.
 - Паметта на стека вече съдържа кадри както за `functionOne`, така и за `functionTwo`.

3. **Извикване на функция три от функция две**
 - `functionTwo` извиква `functionThree`, добавяйки още една стекова рамка.
 - Локалните променливи и параметри за `functionThree` се съхраняват в неговата рамка.
 - Сега паметта на стека има рамки за `functionOne`, `functionTwo` и `functionThree`.

### Създаване на обект

1. **Създаване на обект във функция три**
 - Ако създадем нов обект (напр. `House house = new House();`), този обект се съхранява в паметта на стека.
 - Препратка към този обект се съхранява в рамката на стека на `functionThree`.

2. **Връщане от функция три**
 - След завършване на `functionThree`, неговата стекова рамка се премахва от паметта на стека.
 - Препратката към обекта `House` остава в паметта, но трябва да я управляваме ръчно.

3. **Завръщане от функция две**
 - След завършване на `functionTwo`, неговата стекова рамка също се премахва от паметта на стека.
 - Сега се връщаме към `functionOne`.

4. **Връщане от функция едно**
 - Накрая, когато `functionOne` завърши, неговата стекова рамка се премахва.
 - Паметта на стека вече е празна, но обектът в паметта на стека все още съществува.

### Управление на паметта

- **C++ управление на паметта**: В C++ трябва ръчно да освободим паметта, разпределена за обекти в паметта на стека (напр., използвайки `delete`).
- **Събиране на боклук на други езици**: Езици като Java използват събиране на боклук, за да управляват автоматично неизползваните обекти в паметта на стека.

## Заключение

- **Stack Memory**: Съхранява локални променливи и информация за извикване на функции; стековите рамки се премахват, когато функциите приключат с изпълнението си.
- **Heap Memory**: Съхранява динамично разпределени обекти; препратките към тези обекти се съхраняват в стекови рамки.

Разбирането на разликите между паметта на стека и купчината е от решаващо значение за ефективното програмиране и управление на паметта. Чрез визуализиране на процеса на извикване на функция и създаване на обект, можем по-добре да разберем как паметта се разпределя и освобождава по време на изпълнение на програмата.
