# Внедряване на двоично търсене

В тази лекция ще обсъдим реализацията на алгоритъма за двоично търсене.

## Дефиниране на функцията за търсене

Първо, трябва да дефинираме функция за търсене. Тази функция ще изисква следните параметри:

1. **Integer Array**: Масивът, в който търсим даден елемент.
2. **Нисък индекс**: Началният индекс на пространството за търсене.
3. **Висок индекс**: Крайният индекс на пространството за търсене.
4. **Артикул**: Артикулът, който търсим.

### Примерна настройка

Нека да разгледаме прост пример с масив от цели числа: „[1, 2, 3, 4, 5]“.

- **Ниският индекс** сочи към първия елемент (0).
- **Високият индекс** сочи към последния елемент (4).

Като се има предвид, че масивът е сортиран, можем да използваме ефективно двоично търсене.

## Процес на търсене

1. **Среден елемент**: Изчислете средния индекс като `среден = (нисък + висок) / 2`. Въпреки това, за да избегнем препълване в случаи на големи индекси, можем да използваме:
 \[
 среден = нисък + (висок - нисък) / 2
 \]

2. **Сравнения**:
 - Ако средният елемент е равен на целевия елемент, върнете средния индекс.
 - Ако целевият елемент е по-малък от средния елемент, стеснете търсенето до левия подмасив, като зададете `високо = средно - 1`.
 - Ако целевият елемент е по-голям, стеснете търсенето до десния подмасив, като зададете `ниско = средно + 1`.

3. **Основен случай**: Ако „ниско“ е по-голямо от „високо“, това означава, че търсенето е пропуснато (елементът не е намерен) и връщаме „-1“.

### Рекурсивна функция

Тази реализация използва рекурсия на опашката:

```cpp
int binarySearch(int nums[], int low, int high, int target) {
 ако (ниско > високо) {
 връщане -1; // Пропуснете търсене
 }

 int mid = ниско + (високо - ниско) / 2; // Избягвайте преливане

 if (nums[mid] == цел) {
 връщане по средата; // Елементът е намерен
 }

 if (target <nums[mid]) {
 return binarySearch(nums, low, mid - 1, target); // Търсене вляво
 } иначе {
 връщане на binarySearch(nums, mid + 1, high, target); // Търсене вдясно
 }
}
