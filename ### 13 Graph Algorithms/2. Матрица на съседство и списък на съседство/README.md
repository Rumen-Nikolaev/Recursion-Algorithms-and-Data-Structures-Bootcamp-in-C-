# Матрица на съседство и списък на съседство

В тази лекция ще обсъдим как да представяме графики в езиците за програмиране, като се фокусираме върху две основни представяния: **списък на съседство** и **матрица на съседство**.

## 1. Графично представяне

Графът се състои от върхове (възли) и ръбове (връзки между възли). Когато внедряваме графики в програмирането, можем да избираме между две общи представяния:

- **Списък на съседство**
- **Матрица на съседство**

### 1.1 Списък на съседство

Списъкът на съседство е структура от данни, която представлява графика като масив от списъци. Всеки индекс на масива съответства на връх в графиката и съдържа списък от съседни върхове и техните тегла на ръбовете.

#### Пример

За насочен граф с върхове A, B, C и D, където ръбовете и теглата са дефинирани, списъкът на съседство може да изглежда така: Връх A: [(C, 4), (B, 2)] Връх B: [(D, 3)] Връх C: [] Връх D: []


В това представяне:
- Върх A е свързан с Връх C с тегло 4 и Връх B с тегло 2.
- Връх B се свързва с връх D с тегло 3.
- Върховете C и D нямат изходящи ръбове.

#### Предимства
- Ефективно пространство за **разредени графики** (малко ръбове).
- Лесен за итерация през всички ръбове.

#### Недостатъци
- Неефективно за **плътни графи** (много ръбове).
- Търсенето на тегло на ръба може да бъде бавно, с линейна времева сложност.

### 1.2 Матрица на съседство

Матрицата на съседство е 2D масив (или матрица), който представлява графика, където всяка клетка в позиция „[i][j]“ показва теглото на ръба от върха „i“ до върха „j“. Размерът на матрицата е `V x V`, където `V` е броят на върховете.

#### Пример

За същия насочен граф с върхове A, B, C и D, матрицата на съседство ще бъде: A B C D

A | 0 2 4 0 B | 0 0 0 3 C | 0 0 0 0 D | 0 0 0 0

В тази матрица:
- Стойността „2“ в „[A][B]“ показва ребро от A до B с тегло 2.
- Стойността „4“ в „[A][C]“ показва ребро от A до C с тегло 4.
- Стойността `0` показва, че не съществува ръб между върховете.

#### Предимства
- Бързо търсене на тегло на ръба при постоянна времева сложност.
- Ефективно пространство за **плътни графики**.

#### Недостатъци
- Изисква O(V²) памет, която може да бъде неефективна за големи графи с много върхове, но малко ръбове.
- Итерацията по всички ръбове отнема O(V²) времева сложност.
